"""
This Python module defines a set of models and request/response classes for various interactive features, along with utility classes for generating interactive feature props.

Key Components and Functionalities:

1. **Models:**
   - Defines base models like `Query`, `Document`, `Result`, and specific models like `TextScorerInput`, `ResetStashInput`, etc.
   - Models are used to represent data structures for input and result objects.

2. **Request Models:**
   - Defines request models like `RetrieveRequest`, `TextSlidingRequest`, `TextScorerRequest`, etc.
   - Request models inherit from the base `IRequest` model and specify the input structure for various interactive features.

3. **Result Models:**
   - Defines result models like `TextSlidingResult`, `TextScorerResult`, etc.
   - Result models represent the structure of the output generated by the interactive features.

4. **API Response Model:**
   - `ApiResponse` model defines the structure of API responses, containing result data and generated code.

5. **Interactive Feature Props:**
   - Defines `IColumns` and `IParameters` models for representing column and parameter details.
   - `InteractiveFeatureProps` model represents the structure of interactive feature props, including examples, parameters, input columns, and output columns.
   - `MultiInteractiveFeatureProps` model is designed to handle multiple options for interactive features.

6. **Functions for Generating Props:**
   - Provides functions for generating base code, index code, columns, parameters, and interactive props for documentation and API responses.

Note: The module relies on external libraries such as `TypedDict`, `BaseModel` from `pydantic`, and `TypedDict` from `typing_extensions`. Ensure these dependencies are installed before using the module in your project.

Review and customize the models and request/response classes according to your specific requirements before integrating them into your application.
"""

from typing import List, Union, Tuple
from typing_extensions import TypedDict
from pydantic import BaseModel

# Base Model
class Query(TypedDict):
    qid: str
    query: str


class Document(TypedDict):
    docno: str
    body: str


class Result(Query):
    docno: str
    score: float


class IRequest(BaseModel):
    input: List[TypedDict]


class QueryExpanssionRequest(IRequest):
    input: List[Result]
    fb_terms: int
    fb_docs: int
    qre_dataset: str


class QueryExpansionResult(Query):
    query_0: str


class T5Model(Result):
    rank: int
    text: str


class DocumentText(TypedDict):
    docno: int
    text: str


# Input model
class TextScorerInput(Query, Document):
    pass


class ResetStashInput(Query):
    stashed_results_0: str


class DrScorerInput(Query, DocumentText):
    pass


# Request Model
class RetrieveRequest(IRequest):
    dataset: str
    wmodel: str
    num_results: int
    input: List[Query]


class TextSlidingRequest(IRequest):
    length: int
    stride: int
    input: List[Document]


class TextScorerRequest(IRequest):
    wmodel: str
    input: List[TextScorerInput]


class MaxPassageRequest(IRequest):
    input: List[Result]


class SequentialDependenceRequest(IRequest):
    input: List[Query]


class Bo1Request(QueryExpanssionRequest):
    pass


class KLRequest(QueryExpanssionRequest):
    pass


class RM3Request(QueryExpanssionRequest):
    fb_lambda: float


class AxiomaticRequest(QueryExpanssionRequest):
    fb_lambda: float


class QEResetRequest(IRequest):
    input: List[QueryExpansionResult]


class TokeniseRequest(IRequest):
    input: List[Query]


class StashRequest(IRequest):
    input: List[Result]


class ResetStashRequest(IRequest):
    input: List[ResetStashInput]


class T5Request(IRequest):
    batch_size: int
    input: List[T5Model]


class DrQueryRequest(IRequest):
    input: List[Query]


class DrDocumentRequest(IRequest):
    input: List[DocumentText]


class DrScorerRequest(IRequest):
    input: List[DrScorerInput]


class DrMultiRequest(IRequest):
    input: List
    type: str
    model: str


class PisaRequest(IRequest):
    input: List[Query]


class PisaDphRequest(PisaRequest):
    pass


class PisaBm25Request(PisaRequest):
    k1: float
    b: float


class PisaPl2Request(PisaRequest):
    c: float


class PisaQldRequest(PisaRequest):
    mu: float


# Result Model
class TextSlidingResult(Document):
    pass


class TextScorerResult(Result):
    rank: int


class MaxPassageResult(TextScorerResult):
    pass


class SequentialDependenceResult(QueryExpansionResult):
    pass


class Bo1Result(QueryExpansionResult):
    pass


class KLResult(QueryExpansionResult):
    pass


class RM3Result(QueryExpansionResult):
    pass


class AxiomaticResult(QueryExpansionResult):
    pass


class TokeniseResult(QueryExpansionResult):
    pass


class ResetStashResult(Result):
    pass


class StashResult(Query):
    stashed_results_0: str


class T5Result(T5Model):
    pass


class DrQueryResult(Query):
    query_vec: str


class DrDocumentResult(DocumentText):
    doc_vec: str


class DrScorerResult(DrScorerInput):
    score: float
    rank: int


class PisaRetrieveResult(Result):
    rank: int


class ApiResponse(BaseModel):
    result: List
    code: str

# Interactive Feature Props


class IColumns(BaseModel):
    name: str
    width: int = None  # Optional, defaults to None if not provided


class IParameters(BaseModel):
    name: str
    id: str
    type: str
    choices: List[str] = None  # Optional, defaults to None if not provided
    default: Union[str, int, float]  # Can be either string or integer or float
    read_only: bool = False


class InteractiveFeatureProps(BaseModel):
    # Array of objects, in Python it's a list of dictionaries
    example: List[dict]
    parameters: List[IParameters]
    input: List[IColumns]
    output: List[IColumns]


class MultiInteractiveFeatureProps(BaseModel):
    options: dict
    parameters: List[IParameters]
